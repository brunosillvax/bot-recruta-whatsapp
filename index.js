// FILE: index.js (VERS√ÉO CORRIGIDA E MELHORADA)

const { default: makeWASocket, useMultiFileAuthState, DisconnectReason, fetchLatestWaWebVersion } = require('baileys');
const { Boom } = require('@hapi/boom');
const pino = require('pino');
const logger = require('./utils/logger'); // Importa o logger centralizado
const axios = require('axios');
const qrcode = require('qrcode');
const FormData = require('form-data');
const config = require('./config');
const commandHandler = require('./commandHandler');
const conversationHandler = require('./conversationHandler');
const passiveHandler = require('./passiveHandler');
const { healthCheck } = require('./utils/healthCheck');
const { autoMemoryManager } = require('./utils/autoMemoryManager');

// A vari√°vel global 'sockInstance' foi removida por n√£o estar sendo utilizada.
// A inst√¢ncia do socket 'sock' √© passada corretamente atrav√©s do objeto de contexto.

// Estado global para graceful shutdown
let isShuttingDown = false;
let sockInstance = null;

// VIGIA DE ERROS GRAVES (MANTIDO, POIS √â UMA BOA PR√ÅTICA)
process.on('uncaughtException', (error, origin) => {
    logger.error(`üö® ERRO GRAVE N√ÉO CAPTURADO:`); // Usando logger.error
    logger.error(`Origem do erro:`, origin); // Usando logger.error
    logger.error(`Detalhes do Erro:\n`, error); // Usando logger.error
    process.exit(1); // Desliga para evitar comportamento inesperado
});

// ============================================
// GRACEFUL SHUTDOWN
// ============================================

/**
 * Fun√ß√£o para realizar shutdown gracioso
 * @param {string} signal - Sinal recebido (SIGTERM, SIGINT, etc)
 */
async function gracefulShutdown(signal) {
    if (isShuttingDown) {
        logger.warn('Shutdown j√° em andamento, ignorando sinal adicional');
        return;
    }
    
    isShuttingDown = true;
    logger.info(`\nüî¥ Recebido sinal ${signal}. Iniciando shutdown gracioso...`);
    
    try {
        // 1. Parar de aceitar novas mensagens/conex√µes
        logger.info('1/5 - Parando de aceitar novas mensagens...');
        
        // 2. Limpar todos os timeouts de usu√°rio
        logger.info('2/5 - Limpando timeouts de usu√°rios...');
        for (const [userId, timeoutId] of userTimeouts.entries()) {
            clearTimeout(timeoutId);
        }
        userTimeouts.clear();
        logger.info(`   ‚úì ${userTimeouts.size} timeouts limpos`);
        
        // 3. Parar health check e auto memory manager
        logger.debug('3/6 - Parando health check e auto memory manager...');
        healthCheck.stop();
        autoMemoryManager.stop();
        logger.debug('   ‚úì Health check e auto memory manager parados');
        
        // 4. Limpar estados de usu√°rio
        logger.info('4/6 - Limpando estados de conversa...');
        const stateCount = userStates.size;
        userStates.clear();
        logger.info(`   ‚úì ${stateCount} estados limpos`);
        
        // 5. Notificar no Discord sobre o shutdown
        logger.info('5/6 - Notificando shutdown no Discord...');
        try {
            const FormData = require('form-data');
            const form = new FormData();
            form.append('content', `üî¥ Bot est√° sendo desligado (${signal}). Voltarei em breve!`);
            await axios.post(config.discordWebhookUrl, form, { 
                headers: form.getHeaders(),
                timeout: 5000 
            });
            logger.info('   ‚úì Notifica√ß√£o enviada');
        } catch (error) {
            logger.warn('   ‚ö† Falha ao enviar notifica√ß√£o de shutdown:', error.message);
        }
        
        // 6. Fechar conex√£o do WhatsApp graciosamente
        logger.info('6/6 - Fechando conex√£o do WhatsApp...');
        if (sockInstance) {
            try {
                await sockInstance.logout();
                logger.info('   ‚úì Logout realizado com sucesso');
            } catch (error) {
                logger.warn('   ‚ö† Erro ao fazer logout:', error.message);
            }
        }
        
        logger.info('‚úÖ Shutdown gracioso conclu√≠do com sucesso!');
        process.exit(0);
        
    } catch (error) {
        logger.error('‚ùå Erro durante shutdown gracioso:', error);
        process.exit(1);
    }
}

// Registra handlers para sinais de t√©rmino
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Handler para erros n√£o tratados de Promise (unhandledRejection)
process.on('unhandledRejection', (reason, promise) => {
    logger.error('üö® Promise Rejection n√£o tratada:', reason);
    logger.error('Promise:', promise);
    // N√£o fazer exit aqui, apenas logar para debugging
});

const userStates = new Map();
const userTimeouts = new Map();

async function connectToWhatsApp() {
    try {
        logger.debug('Debug: Iniciando useMultiFileAuthState...');
        const { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys');
        logger.debug('Debug: useMultiFileAuthState conclu√≠do.');

    // Usar vers√£o espec√≠fica est√°vel do WhatsApp Web
    const version = [2, 3000, 1028716292];
    logger.info(`üì± [Bot] Using WA Web v${version.join(".")} (vers√£o est√°vel)`);

    logger.info('Iniciando o bot do WhatsApp...'); // Usando logger.info
    const sock = makeWASocket({ 
        logger: pino({ level: 'silent' }), 
        auth: state,
        version: version,
        // Melhorias na conex√£o para estabilidade
        connectTimeoutMs: 60_000,
        keepAliveIntervalMs: 30_000,
        retryRequestDelayMs: 250,
        maxMsgRetryCount: 3,
        markOnlineOnConnect: false, // Melhora estabilidade
        syncFullHistory: false, // Melhora performance
        fireInitQueries: true,
        shouldSyncHistoryMessage: () => false, // Melhora performance
        generateHighQualityLinkPreview: false, // Melhora performance
        getMessage: async (key) => {
            return {
                conversation: 'Mensagem tempor√°ria'
            }
        }
    }); // Pino para WaSocket continua silent
    
    // Salva a inst√¢ncia do socket para graceful shutdown
    sockInstance = sock;

    // --- FUN√á√ïES DE GERENCIAMENTO DE ESTADO E TIMEOUT ---
    const setUserTimeout = (userId, from) => {
        clearUserTimeout(userId);
        const timeoutId = setTimeout(() => {
            if (userStates.has(userId)) {
                userStates.delete(userId);
                try {
                    if (from) {
                        sock.sendMessage(from, { text: "Sua sess√£o expirou por inatividade." });
                    }
                } catch (error) {
                    logger.error(`‚ö†Ô∏è Erro ao enviar mensagem de timeout para ${from}:`, error); // Usando logger.error
                }
            }
        }, config.sessionTimeoutMinutes * 60000);
        userTimeouts.set(userId, timeoutId);
    };
    const clearUserTimeout = (userId) => {
        if (userTimeouts.has(userId)) {
            clearTimeout(userTimeouts.get(userId));
            userTimeouts.delete(userId);
        }
    };

    // --- HANDLER DE ATUALIZA√á√ÉO DE CONEX√ÉO ---
    sock.ev.on('connection.update', async (update) => {
        const { connection, lastDisconnect, qr } = update;
        logger.debug(`Debug: connection.update recebido. Status: ${connection}`);
        if (lastDisconnect?.error) {
            logger.debug(`Debug: lastDisconnect error: ${lastDisconnect.error.message}`);
        }
        if (qr) {
            logger.info('QR Code gerado, enviando para o Discord...'); // Usando logger.info
            
            // Gerar QR code no terminal
            qrcode.toString(qr, { type: 'terminal', small: true }, (err, terminalQR) => {
                if (!err) {
                    console.log('\n' + '='.repeat(50));
                    console.log('üì± ESCANEIE O QR CODE ABAIXO COM SEU WHATSAPP:');
                    console.log('='.repeat(50));
                    console.log(terminalQR);
                    console.log('='.repeat(50) + '\n');
                }
            });
            
            // Enviar QR code para o Discord
            qrcode.toBuffer(qr, async (err, buffer) => {
                if (err) { logger.error('Erro ao gerar QR Code:', err); return; } // Usando logger.error
                const form = new FormData();
                form.append('file1', buffer, { filename: 'qrcode.png' });
                try {
                    await axios.post(config.discordWebhookUrl, form, { headers: form.getHeaders() });
                } catch (error) {
                    logger.error('‚ùå Erro ao enviar QR Code para o Discord:', error.message); // Usando logger.error
                }
            });
        }
        if (connection === 'close') {
            const shouldReconnect = (lastDisconnect.error instanceof Boom)?.output?.statusCode !== DisconnectReason.loggedOut;
            logger.warn(`Conex√£o fechada. Motivo: ${lastDisconnect.error?.message}. Tentando reconectar: ${shouldReconnect}`); // Usando logger.warn
            
            if (shouldReconnect) {
                // Delay progressivo para reconex√£o
                const delay = Math.min(1000 * Math.pow(2, 0), 30000); // Come√ßa com 1s, m√°ximo 30s
                logger.info(`Tentando reconectar em ${delay}ms...`);
                setTimeout(() => {
                    if (!isShuttingDown) {
                        connectToWhatsApp();
                    }
                }, delay);
            }
        } else if (connection === 'open') {
            logger.info('‚úÖ Bot conectado e pronto para uso!'); // Usando logger.info
            
            // Inicia health check ap√≥s conex√£o bem-sucedida
            if (config.performance.healthCheck.enabled) {
                healthCheck.start();
            }
            
            // Inicia auto memory manager
            autoMemoryManager.start();
        }
    });

    // --- HANDLER DE ATUALIZA√á√ÉO DE CREDENCIAIS ---
    sock.ev.on('creds.update', saveCreds);

    // --- HANDLER DE NOVOS PARTICIPANTES NO GRUPO ---
    sock.ev.on('group-participants.update', async (event) => {
        if (event.id !== config.allowedGroupId || event.action !== 'add') return;

        // MELHORIA: Itera sobre todos os novos participantes, tornando o c√≥digo mais robusto.
        for (const newMemberId of event.participants) {
            const from = event.id;
            if (!from || !newMemberId) {
                logger.error('‚ö†Ô∏è Tentativa de boas-vindas falhou: ID do grupo ou do novo membro √© inv√°lido.', event); // Usando logger.error
                continue; // Pula para o pr√≥ximo participante se houver erro
            }

            const welcomeText = `Ol√°, @${newMemberId.split('@')[0]}! Seja bem-vindo(a) ao nosso cl√£! ü•≥\n\nEu sou o bot que registra os pontos da guerra. Vou fazer algumas perguntas para cadastrar voc√™:\n\nüìù Nome no jogo\nüìù N√≠vel XP\nüìù Torre Rei\nüìù Trof√©us\n‚öì Defesa Naval\n\nVamos come√ßar! Qual √© o seu *nick (nome de usu√°rio) no jogo*?`;

            userStates.set(newMemberId, { 
                step: 'awaiting_new_player_name',
                playerData: {} 
            });
            setUserTimeout(newMemberId, from);

            try {
                await sock.sendMessage(from, { text: welcomeText, mentions: [newMemberId] });
            } catch (error) {
                logger.error(`‚ö†Ô∏è Erro ao enviar mensagem de boas-vindas para ${from}:`, error); // Usando logger.error
            }
        }
    });

    // --- HANDLER PRINCIPAL DE MENSAGENS ---
    sock.ev.on('messages.upsert', async (m) => {
        // Ignora mensagens durante shutdown
        if (isShuttingDown) {
            logger.debug('Bot em shutdown, ignorando mensagem');
            return;
        }
        
        const msg = m.messages[0];

        // Filtro para ignorar mensagens inv√°lidas, do pr√≥prio bot ou de status
        if (!msg.message || msg.key.fromMe || msg.key.remoteJid === 'status@broadcast') {
            return;
        }

        const from = msg.key.remoteJid;
        
        // Filtro para garantir que o bot s√≥ responda no grupo permitido
        if (from !== config.allowedGroupId) return;

        // Extra√ß√£o de informa√ß√µes essenciais da mensagem
        const userId = msg.key.participant || msg.key.remoteJid;
        const userMessage = (msg.message.conversation || msg.message.extendedTextMessage?.text || "").trim();

        // Ignora mensagens sem texto (ex: apenas imagem, v√≠deo)
        if (!userMessage) return;

        // Fun√ß√£o auxiliar para simplificar o envio de respostas
        const reply = async (text, quotedMessage = msg) => {
            if (!from) {
                logger.error(`‚ö†Ô∏è Erro CR√çTICO: Tentativa de resposta para um destinat√°rio NULO.`); // Usando logger.error
                return;
            }
            try {
                return await sock.sendMessage(from, { text }, { quoted: quotedMessage });
            } catch (error) {
                logger.error(`‚ö†Ô∏è Erro ao enviar mensagem (reply) para ${from}:`, error); // Usando logger.error
            }
        };

        const currentState = userStates.get(userId);
        const context = { sock, msg, from, userId, userMessage, reply, userStates, setUserTimeout, clearUserTimeout, currentState };

        // L√≥gica para o comando de cancelamento de opera√ß√£o
        if (userMessage.toLowerCase() === '/sair' || userMessage.toLowerCase() === '/cancelar') {
            if (currentState) {
                clearUserTimeout(userId);
                userStates.delete(userId);
                return reply("Opera√ß√£o cancelada.");
            }
            return; // Ignora se n√£o houver opera√ß√£o em andamento
        }

        // Roteamento da mensagem:
        
        // 1. Se o usu√°rio est√° no meio de uma conversa, direciona para o 'conversationHandler'
        if (currentState) {
            setUserTimeout(userId, from); // Reseta o timeout a cada nova mensagem na conversa
            return conversationHandler(context);
        }

        // 2. Se n√£o est√° em uma conversa, verifica o tipo de mensagem
        if (userMessage.startsWith('/')) {
            // Se come√ßa com '/', √© um comando, direciona para o 'commandHandler'
            return commandHandler(context);
        } else {
            // Se for uma mensagem normal, direciona para o 'passiveHandler'
            return passiveHandler(context);
        }
    });
    } catch (error) {
        logger.error('‚ùå Erro ao conectar com WhatsApp:', error);
        // Tenta reconectar ap√≥s 5 segundos em caso de erro
        setTimeout(() => {
            if (!isShuttingDown) {
                connectToWhatsApp();
            }
        }, 5000);
    }
}

connectToWhatsApp();